<!DOCTYPE html>
<html>

<head>
    <style>
        #info {
            position: absolute;
            top: 45%;
            width: 100%;
            font-family: 'Courier New', monospace;

            padding: 5px;
            text-align: center;
            font-size: 50px;
            color: #6f7896;
        }

        body {
            /*background-image: linear-gradient(to top, #fbc2eb 0%, #a6c1ee 100%);*/
            background-image: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            margin: 0px;
            overflow: hidden;
        }

        button {
            border: none;
            color: #6f7896;
            background-color: Transparent;
            border-radius: 8px;
            transition-duration: 0.4s;
            /* Safari */
            transition-duration: 0.4s;
            border: 1px solid #6f7896;
        }

        button:hover {
            border: 1px solid #96B9F2;
            background-color: Transparent;
            color: #6f7896;
            box-shadow: 0 5px 20px 0 rgba(0, 0, 0, 0.54), 0 17px 50px 0 rgba(0, 0, 0, 0.19);
        }

    </style>
</head>

<body>
    <!--
        <div id='info'> DESCENDANTS<br>OF THE ABACUS <br>
        </div>
-->
    <script src="./three.js/build/three.min.js"></script>
    <script src="./three.js/examples/js/controls/OrbitControls.js"></script>
    <script src="./three.js/examples/js/loaders/MTLLoader.js"></script>
    <script src="./three.js/examples/js/loaders/OBJLoader.js"></script>
    <script src="./three.js/examples/js/loaders/FBXLoader.js"></script>
    <script src="./three.js/examples/js/libs/dat.gui.min.js"></script>

    <script>
        var camera, scene, renderer, controls;
        var model_map;
        var PI = Math.PI;
        var spotLight, spotLight_box, light_ambient;

        init();
        animate();

        function init() {

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xcccccc );
				scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
				camera.position.set( 0, 3, 0 );

				// controls

				controls = new THREE.OrbitControls( camera, renderer.domElement );
				controls.listenToKeyEvents( window ); // optional

				//controls.addEventListener( 'change', render ); // call this only in static scenes (i.e., if there is no animation loop)

				//controls.enableDamping = true; // an animation loop is required when either damping or auto-rotation are enabled
				//controls.dampingFactor = 0.05;

				//controls.screenSpacePanning = false;

				controls.minDistance = 2;
				controls.maxDistance = 5;

				//controls.maxPolarAngle = Math.PI / 2;

          
                // model
                var mtlLoader = new THREE.MTLLoader();
                mtlLoader.setPath( "./map0405/" );
                mtlLoader.load( 'map.mtl', function( materials ) {

                  materials.preload();

                  var objLoader = new THREE.OBJLoader();
                  objLoader.setMaterials( materials );
                  objLoader.setPath( "./map0405/" );
                  objLoader.load( 'map.obj', function ( object ) {
                    var texture = new THREE.TextureLoader().load("./map0405/Texture.png");
                    object.traverse( function( node ) {
                      if( node.material ) {
                        node.material.side = THREE.DoubleSide;
                      }
                      if (node instanceof THREE.Mesh) {
                        node.material.map = texture;
                      }
                      console.log(node);
                    });
                    model_map = object;
                    scene.add( model_map );
                  });
//                  objLoader.load( 'map.obj', function ( object ) {
//
//                    model_map = object;
//                    //model_map.position.y = -50;
//                    scene.add( model_map );
//
//                  } );

                } );
//				const loader = new THREE.OBJLoader();

				// load a resource
//				loader.load(
//					// resource URL
//					'./map0405/map.obj',
//					// called when resource is loaded
//					function ( object ) {
//						object.position.set(0,0,0);
//						object.scale.set(5, 5, 5);
//						model_left = object;
//						scene.add( model_left );
//
//					},
//					// called when loading is in progresses
//					function ( xhr ) {
//
//						console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
//
//					},
//					// called when loading has errors
//					function ( error ) {
//
//						console.log( 'An error happened' );
//
//					}
//				);

//				const geometry = new THREE.CylinderGeometry( 0, 10, 30, 4, 1 );
//				const material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );
//
//				for ( let i = 0; i < 500; i ++ ) {
//
//					const mesh = new THREE.Mesh( geometry, material );
//					mesh.position.x = Math.random() * 1600 - 800;
//					mesh.position.y = 0;
//					mesh.position.z = Math.random() * 1600 - 800;
//					mesh.updateMatrix();
//					mesh.matrixAutoUpdate = false;
//					scene.add( mesh );
//
//				}

				// lights

				const dirLight1 = new THREE.DirectionalLight( 0xffffff );
				dirLight1.position.set( 1, 1, 1 );
				scene.add( dirLight1 );

				const dirLight2 = new THREE.DirectionalLight( 0x002288 );
				dirLight2.position.set( - 1, - 1, - 1 );
				scene.add( dirLight2 );

				const ambientLight = new THREE.AmbientLight( 0x222222 );
				scene.add( ambientLight );

				//

				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

				controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

				render();

			}

			function render() {

				renderer.render( scene, camera );

			}


    </script>
</body>

</html>